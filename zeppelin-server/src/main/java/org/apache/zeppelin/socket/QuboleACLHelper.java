package org.apache.zeppelin.socket;

import java.net.HttpURLConnection;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;

import javax.servlet.http.HttpServletRequest;

import org.apache.zeppelin.conf.ZeppelinConfiguration;
import org.apache.zeppelin.notebook.Note;
import org.apache.zeppelin.notebook.Notebook;
import org.apache.zeppelin.notebook.NotebookAuthorization;
import org.apache.zeppelin.util.QuboleUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.gson.Gson;

/**
 * This class fetches (from tapp) and maintains
 * ACL for Qubole notebooks. ACLs are fetched in batches,
 * since when a refresh notification from tapp is received,
 * there could be multiple pair of (notebook, qbol_user) ACLs
 * to be fetched. Batch size is configurable from 1 through 20.
 * 
 * Some implementation details:
 * 1. ACLs information is stored in NotebookAuthorization, the OSS way.
 * 2. ACLsPresent map in this class is used to maintain which ACLS need
 *    to be refreshed when tapp notifies (refresh_acl api call).
 * 3. All the live connections (open FCN notebooks in browsers), are stored
 *    in ACLsPresent, and ACLS related to only those are refreshed (when needed).
 *
 * Index:
 *   1. noteId:     numeric Id of notebooks generated by tapp
 *   2. zeppelinId: string guid of notebooks generated by zeppelin
 */
public class QuboleACLHelper implements Runnable {

  private static Logger LOG = LoggerFactory.getLogger(QuboleACLHelper.class);
  private static final int TappBatchCallSize =
      ZeppelinConfiguration.create().getBatchSizeForRefreshACLCallToTapp();

  private static final Map<String, QbolUserInfo> ACLsPresent = new HashMap<>();
  private static final ScheduledExecutorService service =
      Executors.newSingleThreadScheduledExecutor();

  private static final Map<String, String> PermissionMapping = new HashMap<>();
  static {
    PermissionMapping.put("update", "writers");
    PermissionMapping.put("read", "readers");
    PermissionMapping.put("delete", "deleters");
  }

  private final Notebook notebook;
  private final String zeppelinIdToRefresh;

  private QuboleACLHelper(Notebook notebook, String zeppelinIdToRefresh) {
    this.notebook = notebook;
    this.zeppelinIdToRefresh = zeppelinIdToRefresh;
  }

  public static void refreshACLs(Notebook notebook, String zepIdToRefresh) {
    LOG.info("Received tapp notification to refresh ACLs");
    service.execute(new QuboleACLHelper(notebook, zepIdToRefresh));
  }

  @Override
  public void run() {
    /* Storing the ACLs to be removed because we do not want to
     * lock the 2 locks (one on finding ACLs to be fetched and the other
     * lock to update NotebookAuthorization) at the same time.
     */
    List<ZeppelinQbolUserPair> aclsToRemove = new ArrayList<>();

    /* Need a copy 'aclsToFetch' of 'ACLsPresent' because of
     * use-case of single notebook's ACLs refresh.
     */
    Map<String, QbolUserInfo> aclsToFetch = new HashMap<>();

    synchronized (ACLsPresent) {
      for (String zeppelinId: ACLsPresent.keySet()) {
        // Only fetching ACLs for a particular notebook.
        if (zeppelinIdToRefresh != null && !zeppelinId.equals(zeppelinIdToRefresh)) {
          continue;
        }
        QbolUserInfo qbolUserSockets = ACLsPresent.get(zeppelinId);
        aclsToFetch.put(zeppelinId, qbolUserSockets);

        for (String qbolUserId: qbolUserSockets.keySet()) {
          Set<NotebookSocket> socks = (Set<NotebookSocket>) qbolUserSockets.get(qbolUserId);
          if (socks.isEmpty()) {
            LOG.info("Not refreshing and removing ACLs for zeppelinId={} and qbolUserId={} "
                + "since no web-socket connection is present.", zeppelinId, qbolUserId);
            qbolUserSockets.remove(qbolUserId);
            aclsToRemove.add(new ZeppelinQbolUserPair(zeppelinId, qbolUserId));
          }
        }
      }
    }
    for (ZeppelinQbolUserPair toRemove: aclsToRemove) {
      updateNotebookAuthorization(notebook, null, toRemove.getZeppelinId(),
          toRemove.getQbolUserId());
    }
    addNotebookACL(notebook, aclsToFetch);
  }

  public static void checkAndAddNotebookACL(Notebook notebook, String qbolUserId,
      String zeppelinId, NotebookSocket conn) {
    if (qbolUserId == null) {
      LOG.warn("qbolUserId is null, hence no ACL is fetched");
      return;
    }
    Note note = notebook.getNote(zeppelinId);
    if (note == null) {
      LOG.warn("No notebook with id = {}, hence no ACL is fetched", zeppelinId);
      return;
    }

    boolean aclPresent = true;
    synchronized (ACLsPresent) {
      //remove conn from some other map if present
      if (conn != null) {
        for (String zepId: ACLsPresent.keySet()) {
          ACLsPresent.get(zepId).removeConn(conn);
        }
      }

      if (!ACLsPresent.containsKey(zeppelinId)) {
        // One qbolUser can open a particular notebook in multiple browsers,
        // hence the 'Set' of connections.
        ACLsPresent.put(zeppelinId, new QbolUserInfo(
            (Map) new HashMap<String, Set<NotebookSocket>>()));
      }
      QbolUserInfo qbolUserSockets = ACLsPresent.get(zeppelinId);
      if (!qbolUserSockets.containsKey(qbolUserId)) {
        aclPresent = false;
        qbolUserSockets.put(qbolUserId, new HashSet<NotebookSocket>());
      }
      if (conn != null) {// i.e. not a REST API call
        qbolUserSockets.addConnection(qbolUserId, conn);
      }
    }
    if (aclPresent) {
      LOG.info("ACLs for qbolUserId={} and zeppelinId={} already available.",
          qbolUserId, zeppelinId);
      return;
    }

    addSingleNotebookACL(notebook, zeppelinId, qbolUserId);
  }

  /* 'addNotebookACL' takes multiple ACLs to fetch.
  *  This function converts single ACL call to multiple.
  */
  private static void addSingleNotebookACL(Notebook notebook, String zeppelinId,
      String qbolUserId) {
    Map<String, Object> tmpMap = new HashMap<>();
    tmpMap.put(qbolUserId, null);
    Map<String, QbolUserInfo> mapToAddACL = new HashMap<>();
    mapToAddACL.put(zeppelinId, new QbolUserInfo((Map) tmpMap));
    addNotebookACL(notebook, mapToAddACL);
  }

  private static void addNotebookACL(Notebook notebook, Map<String, QbolUserInfo> aclsToFetch) {
    //create sublists of noteId and qbolUserId
    List<Map<String, String>> tappCallList = new ArrayList<>();

    Map<String, QbolUserInfo> fetchedACLs = new HashMap<>();
    Integer counter = 0;

    for (String zeppelinId: aclsToFetch.keySet()) {
      Note note = notebook.getNote(zeppelinId);
      if (note == null) {
        LOG.error("Not fetching ACLs for note with zeppelinId={} since note is null", zeppelinId);
        continue;
      } else if (note.getQuboleNoteAttributes() == null) {
        LOG.error("Not fetching ACLs since quboleNoteAttributes is null for "
            + "zeppelinId={}", zeppelinId);
        continue;
      }
      QbolUserInfo qbolUsers = aclsToFetch.get(zeppelinId);
      for (String qbolUserId: qbolUsers.keySet()) {
        Map<String, String> permMap = new HashMap<>();
        permMap.put("note_id", note.getQuboleNoteAttributes().getNoteId().toString());
        permMap.put("qbol_user_id", qbolUserId);
        permMap.put("zeppelin_id", zeppelinId);
        tappCallList.add(permMap);
        counter += 1;
        if (counter == TappBatchCallSize) {
          fetchACLBatch(tappCallList, fetchedACLs, counter);
          tappCallList = new ArrayList<>();
          counter = 0;
        }
      }
    }
    if (counter != 0) {
      fetchACLBatch(tappCallList, fetchedACLs, counter);
    }

    for (String zeppelinId: aclsToFetch.keySet()) {
      Map<String, Object> qbolUsersMap = aclsToFetch.get(zeppelinId);
      for (String qbolUserId: qbolUsersMap.keySet()) {
        if (!fetchedACLs.containsKey(zeppelinId) ||
            !fetchedACLs.get(zeppelinId).containsKey(qbolUserId)) {
          /* If some permission could not be fetched, we should remove
           * them so that zeppelin can try to fetch again on next call.
           */
          synchronized (ACLsPresent) {
            if (ACLsPresent.containsKey(zeppelinId)) {
              ACLsPresent.get(zeppelinId).remove(qbolUserId);
            }
          }
          LOG.info("Removing ACLs for zeppelinId={} and qbolUserId={} since "
              + "there was no response from tapp", zeppelinId, qbolUserId);
          updateNotebookAuthorization(notebook, null, zeppelinId, qbolUserId);
        } else {
          updateNotebookAuthorization(notebook,
              (Map) fetchedACLs.get(zeppelinId).get(qbolUserId), zeppelinId, qbolUserId);
        }
      }
    }
  }

  private static void fetchACLBatch(List<Map<String, String>> tappCallList,
      Map<String, QbolUserInfo> fetchedACLs, int count) {
    long startTime = System.currentTimeMillis();
    fetchACLFromTapp(tappCallList, fetchedACLs);
    LOG.debug("Time taken to fetch {} ACLs from tapp = {} ms", count,
        System.currentTimeMillis() - startTime);
  }

  private static void updateNotebookAuthorization(Notebook notebook,
      Map<String, Boolean> perms, String zeppelinId, String qbolUserId) {
    NotebookAuthorization auth = notebook.getNotebookAuthorization();
    for (String perm: PermissionMapping.keySet()) {
      boolean allowed = false;
      if (perms != null && perms.containsKey(perm) &&
          perms.get(perm).equals(true)) {
        allowed = true;
      }
      if (allowed) {
        auth.addPermissionForQubole(zeppelinId, qbolUserId,
            PermissionMapping.get(perm));
      } else {
        auth.removePermissionForQubole(zeppelinId, qbolUserId,
            PermissionMapping.get(perm));
      }
    }
  }

  private static void fetchACLFromTapp(List<Map<String, String>> aclsToFetch,
      Map<String, QbolUserInfo> fetchedACLs) {
    LOG.info("Fetching ACLs in batch from tapp");
    List<Map<String, Object>> permList = fetchACLs(aclsToFetch);
    if (permList == null) return;
    for (Map<String, Object> map: permList) {
      String zeppelinId = (String) map.get("zeppelinId");
      String qbolUserId = (String) map.get("qbolUserId");
      Map<String, Boolean> permissions = (Map<String, Boolean>) map.get("permissions");
      if (!fetchedACLs.containsKey(zeppelinId)) {
        fetchedACLs.put(zeppelinId, new QbolUserInfo(
            (Map) new HashMap<String, Map<String, Boolean>>()));
      }
      fetchedACLs.get(zeppelinId).put(qbolUserId, permissions);
      LOG.info("Permission for zeppelinId={} and qbolUserId={} are {}",
          zeppelinId, qbolUserId, permissions);
    }
  }

  public static void onNoteDelete(String zeppelinId) {
    synchronized (ACLsPresent) {
      ACLsPresent.remove(zeppelinId);
    }
  }

  public static void onConnectionClose(NotebookSocket conn) {
    synchronized (ACLsPresent) {
      for (String zeppelinId: ACLsPresent.keySet()) {
        QbolUserInfo qbolUserSockets = ACLsPresent.get(zeppelinId);
        for (String qbolUserId: qbolUserSockets.keySet()) {
          qbolUserSockets.removeConn(conn);
        }
      }
    }
  }

  public static boolean isOperationAllowed(String zeppelinId,
      HttpServletRequest request, Notebook notebook, Operation operation) {

    // Allow all operations for JobServer notebooks
    if (notebook.getNote(zeppelinId) != null &&
        QuboleUtil.JOBSERVER.equals(notebook.getNote(zeppelinId).getSource())) {
      LOG.info("Allowing {} on notebook={} since this is a JobServer notebook",
          operation, zeppelinId);
      return true;
    }
    String qbolUserId = request.getHeader(QuboleServerHelper.QBOL_USER_ID);
    checkAndAddNotebookACL(notebook, qbolUserId, zeppelinId, null);
    NotebookAuthorization auth = notebook.getNotebookAuthorization();
    Set<String> entity = new HashSet<>();
    entity.add(qbolUserId);
    if (Operation.READ.equals(operation)) {
      return auth.isReader(zeppelinId, entity);
    } else if (Operation.WRITE.equals(operation)) {
      return auth.isWriter(zeppelinId, entity);
    } else if (Operation.DELETE.equals(operation)) {
      return auth.isDeleter(zeppelinId, entity);
    }
    return false;
  }

  private static Map<String, Boolean> getClassLevelPermissions(String qbolUserId) {
    List<Map<String, String>> list = new ArrayList<>();
    Map<String, String> map = new HashMap<>();
    map.put("qbol_user_id", qbolUserId);
    list.add(map);
    List<Map<String, Object>> permsList = fetchACLs(list);
    if (permsList == null || permsList.isEmpty()) return null;
    return (Map<String, Boolean>) permsList.get(0).get("permissions");
  }

  /**
   * 'Create' permission is different from other permissions
   * because it does not involve any particular notebook. This method
   * returns if create of notebooks for the qbolUser is allowed or not.
   * This result has not cached in zeppelin.
   */
  public static boolean canCreateNote(HttpServletRequest request) {

    String qbolUserId = request.getHeader(QuboleServerHelper.QBOL_USER_ID);
    if (qbolUserId == null) return false;
    Map<String, Boolean> perm = getClassLevelPermissions(qbolUserId);
    LOG.info("Class level permissions for qbolUser={} is={}", qbolUserId, perm);
    if (perm == null) return false;
    return perm.get("create");
  }

  private static List<Map<String, Object>> fetchACLs(List<Map<String, String>> listToCall) {
    String response = null;
    try {
      HttpURLConnection conn = QuboleUtil.getPermissions(listToCall);
      response = QuboleUtil.getResponseFromConnection(conn);
    } catch (Exception e) {
      LOG.error("Error while getting permission from tapp", e);
      return null;
    }

    Gson gson = new Gson();
    List<Map<String, Object>> permList = null;
    try {
      permList = (List<Map<String, Object>>) gson.fromJson(response, List.class);
    } catch (Exception e) {
      LOG.error("Error while parsing permissions from tapp", e);
      return null;
    }
    return permList;
  }

  /**
   * List of permissions / operations to fetch from tapp
   */
  public static enum Operation {
    READ,
    WRITE,
    DELETE
  }

  /* These methods are only used for unit-tests */
  public static void enableAccountFeatureForUnitTests() {
    ACLS_ENABLED = true;
  }

  public static QuboleACLHelper getRunnableForUnitTests(Notebook notebook) {
    return new QuboleACLHelper(notebook, null);
  }
}
